#include <reg52.h>
#include <intrins.h>

#define CHAR_HEIGHT 32
#define CHAR_WIDTH CHAR_HEIGHT

#define LEFT_LCD 0
#define RIGHT_LCD 1

#define FOSC 18432000L
#define BAUD 9600

typedef unsigned char UCHAR;
typedef unsigned int UINT;

//sbit是对应可寻址空间的一个位
sbit CS1 = P1^7;
sbit CS2 = P1^6;
sbit RS = P3^5;
sbit RW = P3^4;
sbit E = P3^3;

/*Declare SFR associated with the ADC  地址 */
sfr ADC_CONTR = 0xBC;	//ADC control register
sfr ADC_RES = 0xBD; 	//ADC high 8-bit result register
sfr ADC_LOW2 = 0xBE; 	//ADC low 2-bit result register 存放在RESL低两位中
sfr P1ASF = 0x9D; 	//P1口模拟功能控制寄存器

/*Define ADC operation const for ADC_CONTR 控制字设置 */
#define ADC_POWER 0x80 		//ADC电源控制位0关1开（1）
#define ADC_FLAG 0x10 		//ADC结束标志位，AD转换完后，ADC_FLAG=1，一定要软件清0（1）
#define ADC_START 0x08 		//ADC转换启动控制位，1开始转换，转换结束后为0（1）
#define ADC_SPEEDLL 0x00 	//540 clocks（00）
#define ADC_SPEEDL 0x20 	//360 clocks（01）
#define ADC_SPEEDH 0x40 	//180 clocks（10）
#define ADC_SPEEDHH 0x60 	//90 clocks（11）

UCHAR code digit_code[10][64] = {	{0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0x40,0x40,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xFE,0xFF,0x0F,0x01,0x00,0x00,0x00,0x01,0x07,0xFF,0xFE,0xF0,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0xFF,0x3F,0x00,0x00,0x00,0x00,0x01,0x03,0x07,0x0E,0x0C,0x08,0x08,0x0E,0x07,0x03,0x01,0x00,0x00},/*"0",0*/	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x0C,0x0F,0x0F,0x0F,0x0C,0x08,0x08,0x08,0x00,0x00},/*"1",1*/	{0x00,0x00,0x00,0x00,0x80,0xC0,0x40,0x40,0x40,0x40,0xC0,0xC0,0x80,0x80,0x00,0x00,0x00,0x00,0x1E,0x1F,0x19,0x00,0x00,0x00,0x00,0x00,0x00,0xC1,0xFF,0xFF,0x3E,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0x70,0x38,0x1C,0x0E,0x07,0x03,0x01,0xC0,0xC0,0x00,0x00,0x00,0x0E,0x0F,0x0D,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0E,0x0F,0x03,0x00},/*"2",2*/	{0x00,0x00,0x00,0x80,0x80,0xC0,0x40,0x40,0x40,0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x0F,0x0F,0x00,0x00,0x00,0x00,0x80,0xC1,0xFF,0x7F,0x3E,0x00,0x00,0x00,0x00,0xC0,0xC0,0xC0,0x00,0x01,0x01,0x01,0x03,0x03,0x06,0xFE,0xFC,0xF0,0x00,0x00,0x00,0x03,0x07,0x07,0x0C,0x08,0x08,0x08,0x08,0x0C,0x06,0x07,0x03,0x00,0x00},/*"3",3*/	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xE0,0x70,0x1C,0x0F,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x30,0x3C,0x2E,0x27,0x21,0x20,0x20,0x20,0xFF,0xFF,0xFF,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x0F,0x0F,0x0F,0x08,0x08,0x08,0x00},/*"4",4*/	{0x00,0x00,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00,0xFF,0xFF,0x80,0xC0,0x40,0x40,0x40,0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0xC0,0xC3,0xC3,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x03,0x07,0x04,0x0C,0x08,0x08,0x08,0x08,0x0C,0x07,0x07,0x03,0x00,0x00},/*"5",5*/	{0x00,0x00,0x00,0x00,0x00,0x80,0x80,0xC0,0x40,0x40,0x40,0xC0,0x80,0x80,0x00,0x00,0x00,0x00,0xE0,0xFC,0xFF,0x87,0xC1,0xC0,0x40,0x40,0xC0,0xC3,0x83,0x03,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0x83,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x01,0x07,0x07,0x0E,0x0C,0x08,0x08,0x0C,0x0E,0x07,0x03,0x00,0x00},/*"6",6*/	{0x00,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x0E,0x0F,0x03,0x00,0x00,0x00,0x00,0xE0,0xF8,0x1E,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xFC,0xFF,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x0F,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"7",7*/	{0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0x40,0x40,0x40,0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x3E,0x7F,0xFF,0xF1,0xC0,0xC0,0x80,0x00,0x80,0xC1,0x7F,0x7F,0x1E,0x00,0x00,0xF0,0xFC,0xFE,0x0E,0x03,0x01,0x01,0x03,0x07,0x0F,0x1E,0xFE,0xFC,0xF0,0x00,0x00,0x01,0x03,0x07,0x06,0x0C,0x08,0x08,0x08,0x08,0x0C,0x06,0x07,0x03,0x01,0x00},/*"8",8*/	{0x00,0x00,0x00,0x80,0x80,0xC0,0x40,0x40,0x40,0x40,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0xFC,0xFF,0xFF,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFE,0xF8,0x00,0x00,0x01,0x03,0x07,0x0F,0x0C,0x08,0x08,0x08,0x0C,0x06,0xE7,0xFF,0x7F,0x1F,0x00,0x00,0x00,0x07,0x07,0x0F,0x08,0x08,0x08,0x0C,0x0E,0x07,0x03,0x01,0x00,0x00,0x00},/*"9",9*/		
};

UCHAR code alpha_g[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0x60,0x20,0x20,0x20,0x60,0xE0,0xE0,0xE0,0x60,0x60,0x00,0x00,0x00,0xC7,0xFF,0xFF,0x30,0x20,0x20,0x20,0x30,0x3F,0x1F,0x0F,0x00,0x00,0x00,0x00,0x38,0x7D,0x7F,0xC7,0x83,0x83,0x83,0x83,0x83,0xC6,0x7E,0x7E,0x3C,0x00};/*"g",0*/
	
void lcm_pending()
{
	P2 = 0x00;	//
	RS = 0;
	RW = 1;
	E = 1;		//读状态字
	while(P2^7 == 1);	//等待LCM空闲
	E = 0;		//总线释放
}
	
void delay_lcm()
{
	//LCM延迟
	UCHAR t = 32;
	while (t--)
	    _nop_();	//延时一个机器周期
}

void delay(UCHAR n)
{
	//AD延迟
	UINT x;
	while (n--)
	{
		x = 5000;
		while (x--);
	}
}

//指令设置 控制信号 rs=0 rw=0
void cmd_out(UCHAR cmd)
{
	P2 = 0xFF;	
	lcm_pending();	//等待总线
	RS = 0;
	RW = 0;
	P2 = cmd;
	E = 1;
	delay_lcm();
	E = 0;
}
//显示开关设置
void switch_on()
{
	cmd_out(0x3F);
}
void switch_off()
{
	cmd_out(0x3E);
}
//显示起始行设置
void set_init_line_ptr(UCHAR line)
{
	cmd_out(0xC0 | line);
}
//页面地址设置
void set_page_ptr(UCHAR page)
{
	cmd_out(0xB8 | page);
}
//列地址设置
void set_column_ptr(UCHAR column)
{
	cmd_out(0x40 | column);
}


//LCM显示 rs=1 rw=0
void write_data(UCHAR dt)
{
	P2 = 0xFF;
	lcm_pending();	//等待总线
	RS = 1;
	RW = 0;		//写显示数据
	P2 = dt;	//将数据写入液晶屏，Y地址计数器自加
	E = 1;
	delay_lcm();
	E = 0;
	//CS1 = 0;	//左半屏显示
}

//LCM初始化 全部清0
void reset_lcm()
{
	UCHAR i = 0, j = 0;
	CS1 = 1;
	CS2 = 1;		//关闭显示
	set_init_line_ptr(0);	//起始行 z
	for (i = 0; i < 8; i++)
	{
		set_page_ptr(i);		//页面选择 x
		set_column_ptr(0);		//列地址 y
		for (j = 0; j < 64; j++)
			write_data(0x00);	//数据全部置0（清除）
	}
	CS1 = 0;
	CS2 = 0;		//开启显示
}

//部分显示
void dispaly_alnum(UCHAR xpage_offset, UCHAR y_offset, UCHAR* ptr)
{
	UCHAR i = 0, j = 0, yj;
	
	for (i = xpage_offset; i < xpage_offset + CHAR_HEIGHT / 8; i++)//4
	{
		set_column_ptr(y_offset);	//列地址设置
		for (j = y_offset; j < y_offset + CHAR_WIDTH / 2; j++)//16
		{
			yj = j;
			if (yj < 64)		//判断哪一块屏该亮
			{
				//右半屏
				CS1 = 1;
				CS2 = 0;
			}
			else
			{
				//左半屏
				CS1 = 0;
				CS2 = 1;
				yj -= 64;
			}
			set_page_ptr(i);		//页面地址设置
			set_column_ptr(yj);		//列地址设置
			
			write_data(*(ptr));
			ptr++;			//偏移自加
		}
	}
	
	CS1 = 0;
	CS2 = 0;
}

//显示重量
void display_weight(UCHAR w)
{
	//显示数字
	dispaly_alnum(2, 32, digit_code[w / 100]);	//百
	dispaly_alnum(2, 48, digit_code[w / 10 % 10]);	//十
	dispaly_alnum(2, 64, digit_code[w % 10]);	//个
	//显示g		
	dispaly_alnum(2, 80, alpha_g);
}

//工作方式的全双工串行通信接口
void init_uart()
{
	SCON = 0x5a; 	//8 bit data ,no parity bit 串行控制寄存器
	TMOD = 0x20; 	//T1 as 8-bit auto reload
	TH1 = TL1 = -(FOSC/12/32/BAUD); 	//Set Uart baudrate
	TR1 = 1;
}

//a/d转换初始化
void init_adc()
{
	P1ASF = 0x01; 	//P1口模拟功能控制寄存器
	ADC_RES = 0; 	//结果寄存器清空
	ADC_CONTR = ADC_POWER | ADC_SPEEDLL;
	delay(2); 	//ADC电源启动并延时
}


UCHAR get_ad_result(UCHAR channel)
{
	ADC_CONTR = ADC_POWER | ADC_SPEEDLL | channel | ADC_START;
	_nop_();
	_nop_();
	_nop_();
	_nop_();
	while (!(ADC_CONTR & ADC_FLAG)); 	//等待A/D转换完成
	ADC_CONTR &= ~ADC_FLAG; 		//二进制取反 关闭ADC
	return ADC_RES;
}


void main()
{
	init_uart();	//总线初始化
	init_adc();	//ad初始化
	lcm_pending();	//等待LCM
	switch_on();
	reset_lcm();	//LCM初始化
	
	display_weight(123);
	while (1)
	{
		UCHAR res = get_ad_result(0);		//称重并从ADC中取结果
		res = res == 0 ? 0 : (res) * 2 / 1.5 + 10 ;	//软件调零，自己改
		display_weight(res);
	}

}
